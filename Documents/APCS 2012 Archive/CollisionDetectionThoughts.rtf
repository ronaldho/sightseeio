{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww19000\viewh20780\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 Platform has two points to indicate where it is drawn. \
\
Platform has the foliowing:\
-starting X (known as getX() )\
-starting Y (known as getY() )\
\
-ending X which we will call getEndingX()\
-ending Y which we will call getEndingY()\
\
For each frame that is being drawn\
	for object.getX() to object.getEndX()\
		check if character.getX() intersects with any of these points\
			if so, then push back the character 7 pixels\
				^\
				|\
				|\
			This here will create a floating style platform\
\
\
NOTES:\
\
Platform Right X =~ 532  EndingX = 649\
\
\
######################################################2ND ATTEMPT################################################\
\
\
Here we are going to use two rectangles\
\
Goal:\
draw invisible rectangle behind both the platform and the character. Also, when enemy implementation comes, we set will make one around that\
\
The collision detection here will use rectangles and check if they are intersecting. If so, then we will run some sort of implementation after that.\
\
For each frame that is being drawn\
	check if any of the rectangle points intersect\
		if so, then push the character back until the rectangles do not intersect\
				^\
				|\
				|\
	 		As in the first attempt, this should create a floating character on the platform, but due to frame speed, the user will not see this happening\
\
\
Ytrigger}